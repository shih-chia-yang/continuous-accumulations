# 2020-12-20

[[sql-server-2019]]

[5 Bigquery SQL Commands You [Probably] Didn’t Know About](https://towardsdatascience.com/5-bigquery-sql-commands-you-probably-didnt-know-about-ebfd9d0dc160)

1. JSON Column To Table

    official document [JSON functions in Standard SQL](https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions)

2. Partition By

    the group by function requires you to group data by columns ,what if you don't want to group them, what if you want to keep all the existing rows while still aggregating data.
    想要保留現有資料列，進行數據分組

3. Having

    - must have a Group By or any aggregation present in the working query
    - occurs after any said aggregation, before order by. The Where clause, on the other hand, occurs before any aggregation

    ````text
    #Looking for revenue > 100Select * from(
    Select
    date,
    customerID,
    sum(revenue) as revenue_sum
    from dataset
    group by 1,2) 
    where revenue_sum > 100
    
    ````

    等價

    ````text
    Select
    date,
    customerID,
    sum(revenue) as revenue_sum
    from dataset
    group by 1,2
    having revenue_sum > 100
    ````

4. Regex

[`Regex Document`](https://www.rexegg.com/regex-quickstart.html)

- REGEXP_CONTAINS

    REGEXP_CONTAINS returns TRUE if the string(value) provided is a partial match for the regular expression (regexp).

    ````text
    #^P means string starts with the character P
    Select
    *
    from dataset 
    where REGEXP_CONTAINS(customerID, '^P')
    ````

- REGEXP_REPLACE

    REGEXP_REPLACE searches for a specific Regex pattern from the provided string(value) and replaces it with whatever you specified.
    ````text
    select 
    *,
    REGEXP_REPLACE(customerID,'^P','Starts with P')
    from dataset
    ````text

- REGEXP_EXTRACT

    REGEXP_EXTRACT returns the first substring from the string(value) provided that matches the Regex pattern specified .
    ````text
    select 
    *,
    REGEXP_EXTRACT(customerID,'[a-zA-Z]')
    from dataset
    ````

5. With
    The With Clause contains subqueries that run every time a subsequent SELECT statement runs. It can be referenced anywhere of your query including joins, unions, and wheres.

    ````text
    WITH q1 AS (my_query)
    SELECT *
    FROM
    (WITH q2 AS (SELECT * FROM q1) SELECT * FROM q2)WITH q1 AS (my_query)
    SELECT *
    FROM q2 a
    left join my_query b on 
    a.id = b.id
    ````

## nano services with ASP.NET Core or how to build a light API

[[netcore]]

[網站連結](https://anthonygiretti.com/2020/06/29/nano-services-with-asp-net-core-or-how-to-build-a-light-api/)

## Route to json

[[Route-to-json]]
[Basic JSON APIs with Route-to-code in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/web-api/route-to-code?view=aspnetcore-5.0)

* Feature not provided by Route-to-code include:
    1. model binding(模型繫結)
    2. model validation(模型驗證)
    3. OpenAPI/swagger(OpenApi/Swagger)
    4. Content negotiation(內容協商)
    5. Constructor dependency injection(函數相依性插入)
    6. ProblemDetails

[Content negotiation](https://www.infoworld.com/article/3083273/how-to-work-with-content-negotiation-in-web-api.html)


## 

[//begin]: # "Autogenerated link references for markdown compatibility"
[sql-server-2019]: ../SqlServer/sql-server-2019.md "Sql Server 2019"
[netcore]: ../netcore/netcore.md "netcore"
[Route-to-json]: ../net core/route-to-json.md "Route to Json"
[//end]: # "Autogenerated link references"
