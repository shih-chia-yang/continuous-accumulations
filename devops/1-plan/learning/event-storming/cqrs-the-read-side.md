# cqrs-the-read-side

[[eventstorming]]

書中多次提到 generic repository that returns `IQueryable<T>` 或是free filter properties不但會隱藏業務意義，還會資料庫效能造成重大影響，可能會有大量的重新連接和未建立索引的查詢

- 因method名稱多是filter or Get，無法一眼就得知查詢的目的，必須進入函式閱讀每一行程式碼，才能了解該查詢的意圖。
- 目前的系統就是使用generic repository，的確如上述所表達，當有複雜查詢時，大多有效能問題，與無法得知詳細需要什麼資料，必須瀏覽每一行linq陳述式與條件限制


目前已完成ClassifiedAd core domain，但UserId是屬於另一個domain model，而尚未完成，先圍繞著core domain進行最小限度的建置，以便測試業務流程

完成前置作業，實作UserProfile Aggregate，實現部份業務流程

## 新增UserProfile model

有關驗證、第三方登入、信箱、雙因子驗證、密碼強度問題先暫時不處理，不適合初次建置系統就實作該部份，可能會花費許多時間建置，而在核心業務流程卻無任何進展。

- user profile event
    - user registered
    - profile photo uploaded
    - user full name updated
    - user display name changed

1. 建立domain model，按照property是否有規範格式、限制實作domain primitive
    - UserProfile
    - FullName
    - DisplayName

2. 依照event storming實作domain event
    - RegisterUser
    - UpdateFullName
    - UpdateDisplayName
    - UpdateProfilePhoto

3. 進行domain model unit tests
    - test_new_user_profile
    - test_update_full_name
    - test_update_display_name
    - test_update_photo_url

4. 實作contract與commandhandler
    - `RegisterUserCommandHandler : ICommandHandler<RegisterUserCommand>`
    - `UpdateUserFullNameCommandHandler : ICommandHandler<UpdateUserFullNameCommand>`
    - `UpdateUserDisplayNameCommandHandler : ICommandHandler<UpdateUserDisplayNameCommand>`
    - `UpdateUserProfilePhotoCommandHandler : ICommandHandler<UpdateUserProfilePhotoCommand>`
    
5. 實作EntityTypeConfiguration，進行建置資料庫
    - UserProfileEntityTypeConfiguration

6. 實作Api Controller
    - UserProfileController

6. 設定Startup.cs，使用DI註冊新服務
    - updated StartupExtensionMethods
    
1. REST-Client進行整合測試、功能測試
    - ClassifiedAd.http
    - UserProfile.http


## the query side

commands trigger methods of the aggregates, and following the CQS principle , none of those methods return anything,but instead change the system state.

## CQRS and read-to-write mismatch

repository 的重點在於只處理有關aggregate的狀態，repository的作用在於將domain model與持久化機制隔離，並且可以隨時取得資料，且能還原業務模型的狀態，使流程得以繼續。
而我們能從repository中取得什麼資料，取決於實作內容，且通常bounded context只有一個aggregate是非常少見的。
而需要呈現的資訊目前沒有在呈現在event storming model ，因為big-picture較專注在system behave，而畫面上所有呈現的內容並不被視為system behave，但這部份仍然屬於核心業務，使用者需要看見資訊才能向系統發出要求，進而產生事件執行業務行為。
雖然可以透過Repository interface 增加需要實作的方法來解決，而當我們在Repository實作查詢後，不可避免的是我們可能需要在內容進行多個domain model的組合，但我們可能僅每個aggregate中的幾個屬性即可，large object graphs造成過於頻繁的查詢，導致資料庫效能問題。

更嚴重的情形是，當發現載入過多model時，而開始使用ORM技術中的lazy loading，使得在測試中執行正常，但無狀態的網頁卻會因為需要延遲加載更多資訊，而當送出請求時，卻發生狀態已消失的情況。

CQRS假設沒有系統是讀取次數等同寫入次數的，大多數情況是讀取次數大於寫入次數，兩者之間的差異可能是2個數量級，而沒有資料庫可以針對寫入和讀取進行優化，只能選擇其中一個，通常一開始是針對寫入進行優化，利用第三正規化寫入最少資料量與避免數據重覆的情形，但當需要讀取時，卻開始不斷的join，將第三正規化所拆分的資料組合回來，很快的讀取次數就超過寫入次數。進而開始產生問題。

在如internat of things(IOT)、高頻交易此類型系統，寫入次數遠遠超過讀取次數，開發人員通常會以取消索引、data flatten，減少transaction time和優化寫入。
從本質上，當開發人員試圖解決寫入或讀取的問題，針對command side進行優化時，而query side不可避免的開始受到影響。

## Queries and read models


建構domain model時必須謹慎處理相依問題，使domain model保持純粹，不與任何infrastructure object有任何相依關係，目的是提供一定程度的自由，且從業務角度的方法實現domain logic。
Repository interface作為domain model的一部份，在application layer實作此介面以實現aggregate persistence。
Command作為application service的contract model，api透過command來對domain model執行操作與狀態轉換，如下圖

|outside world| the edge | application | domain
|--|--|--|--|
|Command =>|API =>|Application service =>|Aggregate => Event|
||| v    ^||
|||Repository||
|||Database||


查詢不需要任何業務規則，也不會改變domain model的狀態。

僅需在application layer實作針對資料庫的查詢，且直接返回read model，不需在經過domain model的組合。

|outside world|the edge| application|
|--|--|--|
|Read model <=| API|Query|
||| database|

## implementing queries

實作read side時，不需要更動domain model任何地方，只需專注在application layer side即可。
read model 仍然是整個業務模型的一部份，在event storming以 綠色便利貼呈現。
使用者可以透過read model得到資訊，根據資訊再透過畫面對系統發出執行請求，如同command 是表達系統內部某些操作的意圖，read model同樣也是表達使用者想從系統中取得什麼樣的資訊內容。



[//begin]: # "Autogenerated link references for markdown compatibility"
[eventstorming]: eventstorming.md "eventstorming"
[//end]: # "Autogenerated link references"