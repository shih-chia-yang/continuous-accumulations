# projections-and-queries

[[event-sourcing]]

## events and queries

CQRS主要流行的原因是server需要針對不同的操作進行優化，因此需要分開處理讀取與寫入，對於第三正規化的關聯資料庫，容易寫入，難以讀取，不好應對巨量的transaction loading
並同時保持複雜查詢的效能。
同樣的問題也適用於使用event做為資料庫記錄的系統，通過append的方式儲存業務事件，無法直接取得系統狀態，為了取得特定資料，需要讀取該物件所有的事件流，並滾動更新。假設需要
巨量的數據查詢時，代表著可能需要將整個系統讀取至記憶體，然後再進行包含多個物件的數據集合處理，而這樣的系統根本沒辦法運作。
這就是在event-sourced系統幾乎每個都實作CQRS的原因，有些系統人們稱之為事件源，它不斷更新替代數據庫中的系統狀態，例如，關係數據庫，與系統產生的事件同時發生。有時，這發生在記憶體中，或是在一個transaction中， 如果事件與系統狀態快照存儲在同一數據庫中。在這樣的系統中，您通常會發現事件實際上幾乎沒有用於任何事情。
應用服務不會從事件中加載對象，而是從快照數據庫中獲取最新的對象狀態。說event是這樣的系統中的source of truth有點牽強，本書不會研究這種作法。


## projection

when we were retrieving a subset of attributes from a larger dataset of the whole system state,to be used for queries.

command --->      Application service-|                  |-->   Projection    
                  ^                   |              |---|                |
   read from store|   commit to store |              |subscription        | update
                  |                   V              |                    V
aggregate events--|                       new event                  read model



## subscriptions

read model可能是來自不同的資料庫，使得所有的查詢會最終一致性。
需要了解目標是將event append to stream和read model更新之間的時間間隔最小化，在這2個操作之間的時間內，read model顯示的數據仍是舊的，但不代表不一致，只是不完全是最新的，
經過一段時間延遲，查詢最終會更新至最新數據。
為了盡量減少時間間隔，我們需要確保我們的projections即時接收new event。eventstore在這裡可以提供幫助，因為它有非常好的訂閱功能。有兩種類型的訂閱——catch-up和persistent訂閱，也稱為競爭消費者。主要區別在於檢查點所有權。

檢查點是流中的特定位置。由於投影處理了一個事件，它可以存儲檢查點，因此如果投影重新啟動，它將知道從哪裡開始處理，而不是從列表的開頭投影所有事件。
檢查點的概念在所有處理實時事件處理的系統中都是眾所周知的，例如 kafka 或 Azure 事件中心。
可以使用 sql server 表來存儲事件並使用自動遞增的主標識作為stream position。然後，您可以不斷輪詢此表以獲取新事件，這樣您就可以擁有一個有效的訂閱。

有2種方法可以儲存check point

1. client-based
    - 由client side維護與訂閱
2. server-based
    - event consumer競爭消費者，可進行多個projection

## catch-up subscriptions

## Cross-aggregate projections



[//begin]: # "Autogenerated link references for markdown compatibility"
[event-sourcing]: event-sourcing.md "event-sourcing"
[//end]: # "Autogenerated link references"
